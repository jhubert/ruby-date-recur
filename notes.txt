
def calculate_recurrence(start,type,pattern,ends=start+365)
date = start.dup
dates = []
case type
when 'daily'
  date.step(ends,pattern.to_i) { |d| dates << d }
when 'weekly'
  pattern = "1" if pattern.nil? || pattern == 0
  if !pattern.include?(':')
    date.step(ends,7*pattern.to_i) { |d| dates << d }
  else
    pattern = pattern.split(':')
    pattern[1].to_i.to_s(base=2).reverse.scan(/./).each_with_index do |d,x| 
      if d == "1"
        base = date + (x - date.cwday)
        base = base + 7 if base < date
        base.step(ends,7*pattern[0].to_i) { |d| dates << d }
      end
    end
    dates.sort!
  end
when 'monthly'
  pattern = "1" if pattern.nil?
  if !pattern.include?(':')
    while date < ends
      dates << (date = date>>pattern.to_i)
    end
  else
    pattern = pattern.split(':')
    date = Date.civil(date.year,date.month,1)
    while date < ends
      pattern[1].to_i.to_s(base=2).reverse.scan(/./).each_with_index do |d,x|
        if d == "1"
          next unless Date.valid_civil?(date.year,date.month,x.to_i + 1)
          dt = Date.civil(date.year,date.month,x.to_i + 1)
          break if dt > ends
          dates << dt
        end
      end
      date = date>>pattern[0].to_i
    end
  end
when 'yearly'
end
dates
end

daily:X
weekly:X:XXXXXXX
monthly:X:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
monthly:X:XXXXX:XXXXXXX
yearly:X:XXXXXXXXXXXX
yearly:X:XXXXXXXXXXXX(:XXXXX:XXXXXXX)

Pattern Format:
daily:[every x days]
weekly:[every x weeks]:([integer representing 7 digit binary code])
monthly:[every x months]:([integer representing 31 digit binary code])
yearly:[every x years]:([integer representing 12 digit binary code])

date = Date.today
days.to_s(base=2).scan(/./).each_with_index do |d,x| 
  if d == "1"
    
  end
end

100001000001000000101001010010
111111111111111111111111111111
10010101010




dates = calculate_recurrence(Date.today,'weekly','2:91')
dates.each { |date| p "#{date.strftime('%A %B %d, %Y')}" };nil

1 1 Saturday
2 2 Friday
4 3 Thursday
8 4 Wednesday
16 5 Tuesday
32 6 Monday
64 7 Sunday

require 'date'
date = Date.civil(2009,1)
x = date.cwday
y = 5 # wednesday
y = 7 if y == 0
z = 3 # third week
offset = (7*z - (x - y))
offset -= 7 if y >= x
puts (date + offset).strftime('%A %B %d, %Y')


require 'date'
class Date
  def nth_weekday(nth,day_of_week)
    nth = nth + 1
    last = nth == 6
    nth = 5 if last
    date = Date.civil(self.year,self.month)
    current_week_day = date.cwday
    day_of_week = 7 if day_of_week == 0
    nth -= 1 if day_of_week >= current_week_day
    offset = (7*nth - (current_week_day - day_of_week))
    new_date = date + (7*nth - (current_week_day - day_of_week))
    return new_date if new_date.month == date.month
    return last ? new_date - 7 : nil
  end
end

puts Date.today.nth_weekday(3,3).to_s
puts Date.today.nth_weekday(4,3).to_s
puts Date.today.nth_weekday(6,3).to_s